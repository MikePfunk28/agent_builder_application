/**
 * File Generators for Deployment Packages
 * Separated concerns for better maintainability
 */

import { DEFAULT_RESOURCES, sanitizeAgentName, isAWSDeployment } from "../constants";

interface Agent {
  name: string;
  tools: any[];
  deploymentType: string;
  mcpServers?: any[];
  generatedCode: string;
  model?: string;
  systemPrompt?: string;
}

/**
 * Generate requirements.txt with proper version pinning
 */
export function generateRequirementsTxt(tools: any[], deploymentType: string): string {
  const packages = new Map<string, string>([
    ['strands-agents', '>=1.0.0'],
    ['opentelemetry-api', '>=1.22.0'],
    ['opentelemetry-sdk', '>=1.22.0'],
  ]);

  // Add deployment-specific packages
  if (isAWSDeployment(deploymentType)) {
    packages.set('boto3', '>=1.35.0');
    // bedrock-agentcore is managed by strands-agents-tools[agent-core-code-interpreter]
    // Don't pin it here to avoid conflicts
    packages.set('bedrock-agentcore-starter-toolkit', '>=0.1.21');
  }

  // Collect tool-specific packages
  const extrasSet = new Set<string>();
  for (const tool of tools) {
    if (tool.extrasPip) {
      extrasSet.add(tool.extrasPip);
    }
    if (tool.pipPackages && Array.isArray(tool.pipPackages)) {
      tool.pipPackages.forEach((pkg: string) => {
        const match = pkg.match(/^([a-zA-Z0-9_-]+)(.*)$/);
        if (match) {
          const [, name, version] = match;
          packages.set(name, version || '');
        }
      });
    }
  }

  // Add strands-agents-tools with extras
  if (extrasSet.size > 0) {
    const extras = Array.from(extrasSet).join(',');
    packages.set('strands-agents-tools', `[${extras}]>=1.0.0`);
  } else {
    packages.set('strands-agents-tools', '>=1.0.0');
  }

  return Array.from(packages.entries())
    .map(([name, version]) => `${name}${version}`)
    .join('\n');
}

/**
 * Generate Dockerfile for containerization
 */
export function generateDockerfile(agent: Agent): string {
  const lines = [
    'FROM python:3.11-slim',
    '',
    '# Set working directory',
    'WORKDIR /app',
    '',
    '# Install system dependencies',
    'RUN apt-get update && apt-get install -y \\',
    '    build-essential \\',
    '    curl \\',
    '    git \\',
    '    && rm -rf /var/lib/apt/lists/*',
    '',
    '# Copy requirements file',
    'COPY requirements.txt .',
    '',
    '# Install Python dependencies',
    'RUN pip install --no-cache-dir -r requirements.txt',
    '',
    '# Copy agent code',
    'COPY agent.py .',
    '',
    '# Copy MCP configuration if exists',
    'COPY mcp.json* ./',
    '',
    '# Set environment variables',
    'ENV PYTHONUNBUFFERED=1',
    'ENV BYPASS_TOOL_CONSENT=true',
    `ENV AGENT_NAME="${agent.name}"`,
    '',
    '# Expose port for API',
    `EXPOSE ${DEFAULT_RESOURCES.CONTAINER_PORT}`,
    '',
    '# Run the agent',
    'CMD ["python", "agent.py"]',
  ];

  return lines.join('\n');
}

/**
 * Generate MCP configuration file
 */
export function generateMCPConfig(mcpServers: any[]): string {
  if (!mcpServers || mcpServers.length === 0) {
    return JSON.stringify({ mcpServers: {} }, null, 2);
  }

  const config: any = { mcpServers: {} };

  for (const server of mcpServers) {
    config.mcpServers[server.name] = {
      command: server.command,
      args: server.args,
      env: server.env || {},
      disabled: server.disabled || false,
    };
  }

  return JSON.stringify(config, null, 2);
}

/**
 * Generate deployment script for container deployments
 */
export function generateDeployScript(agent: Agent): string {
  const sanitizedName = sanitizeAgentName(agent.name);
  
  const lines = [
    '#!/bin/bash',
    `# Deployment script for ${agent.name}`,
    '# Generated by Agent Builder Application',
    '',
    'set -e',
    '',
    'echo "Building Docker image..."',
    `docker build -t ${sanitizedName}:latest .`,
    '',
    'echo "Starting agent container..."',
    'docker run -d \\',
    `  --name ${sanitizedName} \\`,
    `  -p ${DEFAULT_RESOURCES.CONTAINER_PORT}:${DEFAULT_RESOURCES.CONTAINER_PORT} \\`,
    '  -e AWS_REGION=${AWS_REGION:-us-east-1} \\',
    '  -e AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} \\',
    '  -e AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} \\',
    '  -e LOG_LEVEL=${LOG_LEVEL:-INFO} \\',
    `  ${sanitizedName}:latest`,
    '',
    'echo "Agent deployed successfully!"',
    `echo "Access the agent at http://localhost:${DEFAULT_RESOURCES.CONTAINER_PORT}"`,
  ];

  return lines.join('\n');
}


/**
 * Generate pyproject.toml for modern Python packaging
 */
export function generatePyprojectToml(tools: any[], deploymentType: string, agentName: string): string {
  const packages = new Map<string, string>([
    ['strands-agents', '>=1.0.0'],
    ['opentelemetry-api', '>=1.22.0'],
    ['opentelemetry-sdk', '>=1.22.0'],
  ]);

  if (isAWSDeployment(deploymentType)) {
    packages.set('boto3', '>=1.35.0');
    // bedrock-agentcore is managed by strands-agents-tools[agent-core-code-interpreter]
    packages.set('bedrock-agentcore-starter-toolkit', '>=0.1.21');
  }

  const extrasSet = new Set<string>();
  for (const tool of tools) {
    if (tool.extrasPip) {
      extrasSet.add(tool.extrasPip);
    }
    if (tool.pipPackages && Array.isArray(tool.pipPackages)) {
      tool.pipPackages.forEach((pkg: string) => {
        const match = pkg.match(/^([a-zA-Z0-9_-]+)(.*)$/);
        if (match) {
          const [, name, version] = match;
          packages.set(name, version || '>=0.0.0');
        }
      });
    }
  }

  if (extrasSet.size > 0) {
    const extras = Array.from(extrasSet).join(',');
    packages.set('strands-agents-tools', `[${extras}]>=1.0.0`);
  } else {
    packages.set('strands-agents-tools', '>=1.0.0');
  }

  const deps = Array.from(packages.entries())
    .map(([name, version]) => `    "${name}${version}",`)
    .join('\n');

  return `[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "${sanitizeAgentName(agentName)}"
version = "0.1.0"
description = "AI Agent powered by Strands Agents"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
${deps}
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.ruff]
line-length = 100
target-version = "py311"
`;
}

/**
 * Generate Lambda handler wrapper
 */
export function generateLambdaHandler(agent: Agent): string {
  return `"""
AWS Lambda Handler for ${agent.name}
Wraps the agent for Lambda execution
"""

import json
import os
from agent import agent  # Import the agent from agent.py

def lambda_handler(event, context):
    """
    AWS Lambda handler function
    
    Expected event format:
    {
        "input": "user query here",
        "session_id": "optional-session-id"
    }
    """
    try:
        # Extract input from event
        user_input = event.get('input', '')
        session_id = event.get('session_id', 'lambda-session')
        
        if not user_input:
            return {
                'statusCode': 400,
                'body': json.dumps({'error': 'Missing input field'})
            }
        
        # Execute agent
        response = agent.run(user_input, session_id=session_id)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'response': response,
                'session_id': session_id
            })
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }
`;
}

/**
 * Generate Lambda deployment script
 */
export function generateLambdaDeployScript(agent: Agent): string {
  const sanitizedName = sanitizeAgentName(agent.name);
  
  return `#!/bin/bash
# Lambda Deployment Script for ${agent.name}
# Deploys agent as AWS Lambda function

set -e

FUNCTION_NAME="${sanitizedName}-lambda"
REGION=\${AWS_REGION:-us-east-1}
ROLE_ARN=\${LAMBDA_ROLE_ARN}

if [ -z "$ROLE_ARN" ]; then
    echo "Error: LAMBDA_ROLE_ARN environment variable not set"
    echo "Create a Lambda execution role with Bedrock permissions first"
    exit 1
fi

echo "📦 Building deployment package..."
mkdir -p lambda_package
pip install -r requirements.txt -t lambda_package/
cp agent.py lambda_package/
cp lambda_handler.py lambda_package/
cp mcp.json lambda_package/ 2>/dev/null || true

echo "🗜️  Creating ZIP archive..."
cd lambda_package
zip -r ../lambda_deployment.zip . -q
cd ..

echo "☁️  Deploying to AWS Lambda..."
aws lambda create-function \\
    --function-name $FUNCTION_NAME \\
    --runtime python3.11 \\
    --role $ROLE_ARN \\
    --handler lambda_handler.lambda_handler \\
    --zip-file fileb://lambda_deployment.zip \\
    --timeout 300 \\
    --memory-size 512 \\
    --region $REGION \\
    --environment Variables="{MODEL_ID=${agent.model}}" \\
    || aws lambda update-function-code \\
        --function-name $FUNCTION_NAME \\
        --zip-file fileb://lambda_deployment.zip \\
        --region $REGION

echo "✅ Lambda function deployed: $FUNCTION_NAME"
echo "Test with: aws lambda invoke --function-name $FUNCTION_NAME --payload '{\\"input\\":\\"Hello\\"}' response.json"

# Cleanup
rm -rf lambda_package lambda_deployment.zip
`;
}

/**
 * Generate AgentCore configuration
 */
export function generateAgentCoreConfig(agent: Agent): string {
  return JSON.stringify({
    agentName: agent.name,
    runtime: "bedrock-agentcore",
    model: agent.model,
    systemPrompt: agent.systemPrompt,
    tools: agent.tools.map((tool: any) => ({
      name: tool.name,
      type: tool.type,
      config: tool.config || {}
    })),
    memory: {
      enabled: true,
      type: "conversation"
    },
    reasoning: {
      enabled: true,
      mode: "interleaved"
    }
  }, null, 2);
}

/**
 * Generate AgentCore deployment script
 */
export function generateAgentCoreDeployScript(agent: Agent): string {
  const sanitizedName = sanitizeAgentName(agent.name);
  
  return `#!/bin/bash
# AgentCore Deployment Script for ${agent.name}
# Deploys to Bedrock AgentCore Runtime

set -e

AGENT_NAME="${sanitizedName}"
REGION=\${AWS_REGION:-us-east-1}

echo "🚀 Deploying to Bedrock AgentCore..."

# Package agent code
echo "📦 Packaging agent..."
tar -czf agent_package.tar.gz agent.py requirements.txt mcp.json agentcore_config.json

# Upload to S3 (AgentCore will pull from here)
S3_BUCKET=\${AGENTCORE_BUCKET:-agentcore-deployments}
S3_KEY="agents/$AGENT_NAME/$(date +%s)/agent_package.tar.gz"

aws s3 cp agent_package.tar.gz s3://$S3_BUCKET/$S3_KEY --region $REGION

# Deploy to AgentCore
echo "☁️  Creating AgentCore runtime..."
aws bedrock-agent create-agent \\
    --agent-name $AGENT_NAME \\
    --agent-resource-role-arn \${AGENTCORE_ROLE_ARN} \\
    --foundation-model ${agent.model} \\
    --instruction "$(cat agentcore_config.json | jq -r '.systemPrompt')" \\
    --region $REGION

echo "✅ AgentCore deployment initiated"
echo "Monitor status: aws bedrock-agent get-agent --agent-id <agent-id> --region $REGION"

# Cleanup
rm agent_package.tar.gz
`;
}

/**
 * Generate comprehensive README with deployment instructions
 */
export function generateDeploymentReadme(agent: Agent, deploymentTarget: string, options: any): string {
  const sanitizedName = sanitizeAgentName(agent.name);
  
  return `# ${agent.name} - Deployment Package

AI Agent powered by [Strands Agents](https://strandsagents.com)

## 📋 Contents

- \`agent.py\` - Main agent implementation
- \`${options.usePyprojectToml ? 'pyproject.toml' : 'requirements.txt'}\` - Python dependencies
- \`Dockerfile\` - Container image definition
- \`mcp.json\` - MCP server configuration
${deploymentTarget === 'lambda' ? '- `lambda_handler.py` - AWS Lambda wrapper\n- `lambda_deploy.sh` - Lambda deployment script\n' : ''}
${deploymentTarget === 'agentcore' ? '- `agentcore_config.json` - AgentCore configuration\n- `deploy_agentcore.sh` - AgentCore deployment script\n' : ''}
${options.includeCloudFormation ? '- `cloudformation.yaml` - AWS infrastructure template\n' : ''}
${options.includeCLIScript ? '- `deploy.sh` - CLI deployment script\n' : ''}

## 🚀 Deployment Options

### Option 1: AWS Lambda (Serverless)

Best for: Event-driven, low-traffic agents

\`\`\`bash
# Set your Lambda execution role ARN
export LAMBDA_ROLE_ARN="arn:aws:iam::YOUR_ACCOUNT:role/lambda-execution-role"

# Deploy
chmod +x lambda_deploy.sh
./lambda_deploy.sh
\`\`\`

**Requirements:**
- AWS CLI configured
- Lambda execution role with Bedrock permissions
- Python 3.11+

### Option 2: ECS Fargate (Containers)

Best for: Always-on agents, high traffic

\`\`\`bash
# Deploy using CloudFormation
aws cloudformation create-stack \\
    --stack-name ${sanitizedName} \\
    --template-body file://cloudformation.yaml \\
    --capabilities CAPABILITY_IAM

# Or use CLI script
chmod +x deploy.sh
./deploy.sh
\`\`\`

**Requirements:**
- Docker installed
- AWS CLI configured
- ECR repository access

### Option 3: Bedrock AgentCore (Managed)

Best for: Production agents, enterprise use

\`\`\`bash
# Set AgentCore configuration
export AGENTCORE_BUCKET="your-agentcore-bucket"
export AGENTCORE_ROLE_ARN="arn:aws:iam::YOUR_ACCOUNT:role/agentcore-role"

# Deploy
chmod +x deploy_agentcore.sh
./deploy_agentcore.sh
\`\`\`

**Requirements:**
- Bedrock AgentCore access
- S3 bucket for agent packages
- AgentCore execution role

### Option 4: Local Docker

Best for: Development and testing

\`\`\`bash
# Build image
docker build -t ${sanitizedName}:latest .

# Run locally
docker run -p 8000:8000 \\
    -e AWS_REGION=us-east-1 \\
    -e AWS_ACCESS_KEY_ID=\${AWS_ACCESS_KEY_ID} \\
    -e AWS_SECRET_ACCESS_KEY=\${AWS_SECRET_ACCESS_KEY} \\
    ${sanitizedName}:latest
\`\`\`

## 🔧 Configuration

### Environment Variables

- \`AWS_REGION\` - AWS region (default: us-east-1)
- \`MODEL_ID\` - Bedrock model ID (default: ${agent.model})
- \`LOG_LEVEL\` - Logging level (default: INFO)
- \`BYPASS_TOOL_CONSENT\` - Skip tool confirmation (default: true)

### Model Configuration

Current model: \`${agent.model}\`

To change the model, update the \`MODEL_ID\` environment variable or modify \`agent.py\`.

## 📊 Monitoring

### CloudWatch Logs

All deployments log to CloudWatch:
- Lambda: \`/aws/lambda/${sanitizedName}-lambda\`
- Fargate: \`/ecs/${sanitizedName}\`
- AgentCore: \`/aws/bedrock/agentcore/${sanitizedName}\`

### Metrics

Key metrics to monitor:
- Invocation count
- Error rate
- Duration (p50, p95, p99)
- Memory usage
- Model token usage

## 🔐 Security

### IAM Permissions Required

\`\`\`json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel",
        "bedrock:InvokeModelWithResponseStream"
      ],
      "Resource": "arn:aws:bedrock:*::foundation-model/*"
    }
  ]
}
\`\`\`

### MCP Authentication

This agent uses MCP servers for tool access. Configure authentication in \`mcp.json\`.

## 💰 Cost Estimation

Approximate costs (us-east-1):

- **Lambda**: $0.20 per 1M requests + model costs
- **Fargate**: ~$0.10/hour when active + model costs
- **AgentCore**: ~$0.15/hour + model costs

Model costs vary by usage. See [AWS Bedrock Pricing](https://aws.amazon.com/bedrock/pricing/).

## 🐛 Troubleshooting

### Common Issues

**"Module not found" errors:**
\`\`\`bash
pip install -r requirements.txt
\`\`\`

**"Access denied" errors:**
- Check IAM role permissions
- Verify AWS credentials are configured
- Ensure Bedrock model access is enabled

**Container fails to start:**
- Check Docker logs: \`docker logs <container-id>\`
- Verify environment variables are set
- Ensure port 8000 is available

## 📚 Documentation

- [Strands Agents Documentation](https://strandsagents.com/latest/documentation/)
- [AWS Lambda Deployment Guide](https://strandsagents.com/latest/documentation/docs/user-guide/deploy/deploy_to_aws_lambda/)
- [Bedrock AgentCore Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html)

## 🤝 Support

For issues or questions:
- GitHub: [Strands Agents](https://github.com/strands-agents)
- Documentation: [strandsagents.com](https://strandsagents.com)
- Community: [Discord](https://discord.gg/strands-agents)

---

Generated by Agent Builder Application
`;
}
